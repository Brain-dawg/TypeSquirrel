#!/usr/bin/env python3
# pylint: disable=missing-function-docstring
# pylint: disable=wildcard-import
# pylint: disable=unused-wildcard-import
# pylint: disable=broad-exception-caught
"""
Usage:
    python squirrel_analyzer.py [options] <file.tnut>
"""

import argparse
import sys
import os
from typing import Optional, Any
from dataclasses import dataclass
from enum import Enum
import re
import json

# ANTLR imports (will be generated)
try:
    from antlr4 import *
    ANTLR_AVAILABLE = True

    # These will be generated by ANTLR

    # from SquirrelParserLexer import SquirrelParserLexer
    # from SquirrelParserParser import SquirrelParserParser
    # from SquirrelParserListener import SquirrelParserListener

except ImportError:
    print("Warning: ANTLR4 not available. Please install antlr4-python3-runtime")
    ANTLR_AVAILABLE = False

from squirrel_types import *

HELP_TEXT = """

    Examples:
    python squirrel_analyzer.py script.tnut                    # Type check only
    python squirrel_analyzer.py --strip script.tnut           # Strip annotations
    python squirrel_analyzer.py --check --strip script.tnut   # Both operations
    python squirrel_analyzer.py --output clean.tnut script.tnut # Save stripped version
"""


class ErrorSeverity(Enum):

    """ Represents an error, warning, or info message from the analyzer """

    ERROR   = "error"
    WARNING = "warning"
    INFO    = "info"


@dataclass
class SourceLocation:

    """ Represents a location in source code """

    line:   int
    column: int
    file:   str = ""

    def __str__(self):
        if self.file:
            return f"{self.file}:{self.line}:{self.column}"
        return f"{self.line}:{self.column}"


@dataclass
class AnalyzerMessage:

    """ Represents an error, warning, or info message from the analyzer """

    severity: ErrorSeverity
    message:  str
    location: SourceLocation
    code: Optional[str] = None

    def __str__(self):
        return f"{self.location}: {self.severity.value}: {self.message}"


# Represents a symbol in the symbol table
@dataclass
class Symbol:

    """ Represents a symbol in the symbol table """

    name: str
    type: SquirrelType
    location: SourceLocation
    is_mutable: bool = True
    is_initialized: bool = False


# Symbol table for tracking variable types and scopes
class SymbolTable:

    """ Represents a symbol table for tracking variable types and scopes """

    def __init__(self, parent: Optional['SymbolTable'] = None):

        self.parent = parent
        self.symbols: dict[str, Symbol] = {}
        self.children: list['SymbolTable'] = []
        if parent:
            parent.children.append(self)

    # Define a symbol in this scope
    def define(self, symbol: Symbol) -> None:

        """ Define a symbol in this scope """
        self.symbols[symbol.name] = symbol

    # Look up a symbol in this scope or parent scopes
    def lookup(self, name: str) -> Optional[Symbol]:

        """ Look up a symbol in this scope or parent scopes """
        if name in self.symbols:
            return self.symbols[name]
        if self.parent:
            return self.parent.lookup(name)
        return None

    # Look up a symbol only in this scope
    def lookup_local(self, name: str) -> Optional[Symbol]:

        """ Look up a symbol only in this scope """
        return self.symbols.get(name)

    # Create a child scope
    def create_child_scope(self) -> 'SymbolTable':

        """ Create a child scope """
        return SymbolTable(self)


# Strips type annotations while preserving formatting
class TypeAnnotationStripper:

    """ Strips type annotations while preserving formatting """

    def __init__(self, source_code: str):

        self.source_code = source_code
        self.lines = source_code.split('\n')
        self.modifications: list[tuple] = []  # (line, start_col, end_col, replacement)

    def strip_annotations(self) -> str:

        """ Strip type annotations while preserving formatting """

        result = self.source_code

        # 1. Strip type annotations like ": int", ": string", ": array<int>", etc.
        type_annotation_pattern = r':\s*([a-zA-Z_][a-zA-Z0-9_]*(?:\s*<\s*[a-zA-Z_][a-zA-Z0-9_]*\s*>)?(?:\s*\|\s*[a-zA-Z_][a-zA-Z0-9_]*(?:\s*<\s*[a-zA-Z_][a-zA-Z0-9_]*\s*>)?)*(?:\s*\[\s*\])?|\{[^}]*\}|\([^)]*\)\s*->\s*[a-zA-Z_][a-zA-Z0-9_]*)'
        result = re.sub(type_annotation_pattern, '', result)

        # 2. Strip standalone array type annotations like "array<int>" that weren't caught
        # Handle nested types like "array<array<int>>" by matching balanced angle brackets
        array_type_pattern = r'<(?:[^<>]*(?:<[^<>]*>[^<>]*)*)>'
        result = re.sub(array_type_pattern, '', result)

        # 3. Strip optional type markers (? characters) that follow identifiers
        optional_pattern = r'([a-zA-Z_][a-zA-Z0-9_]*)\s*\?'
        result = re.sub(optional_pattern, r'\1', result)

        # 4. Fix class member declarations - add " = null" to bare member declarations
        # Look for class member patterns: "    name;" -> "    name = null;"
        class_member_pattern = r'^(\s+)([a-zA-Z_][a-zA-Z0-9_]*)\s*;\s*$'

        lines = result.split('\n')
        in_class = False
        class_brace_count = 0

        for i, line in enumerate(lines):
            # Track if we're inside a class
            if 'class ' in line and '{' in line:
                in_class = True
                class_brace_count = line.count('{') - line.count('}')
            elif in_class:
                class_brace_count += line.count('{') - line.count('}')
                if class_brace_count <= 0:
                    in_class = False
                    class_brace_count = 0

            # If we're in a class and find a bare member declaration, fix it
            if in_class:
                match = re.match(class_member_pattern, line)
                if match and not any(keyword in line for keyword in ['function', 'constructor', 'static']):
                    indent = match.group(1)
                    member_name = match.group(2)
                    lines[i] = f"{indent}{member_name} = null;"

        result = '\n'.join(lines)
        return result

    # Add a modification to strip
    def add_modification(self, line: int, start_col: int, end_col: int, replacement: str = ""):
        """ Add a modification to strip """
        self.modifications.append((line, start_col, end_col, replacement))

    # Apply all recorded modifications
    def apply_modifications(self) -> str:

        """ Apply all recorded modifications """
        self.modifications.sort(key=lambda x: (x[0], x[1]), reverse=True)

        lines = self.lines.copy()
        for line_num, start_col, end_col, replacement in self.modifications:
            if 0 <= line_num < len(lines):
                line = lines[line_num]
                lines[line_num] = line[:start_col] + replacement + line[end_col:]

        return '\n'.join(lines)


# Main type checker class
class SquirrelTypeChecker:

    """ Main type checker class """

    annotation_style = 1 # 1: colon separator, 2: C-style space separator

    # Initialize built-in symbols
    def __init__(self):

        self.messages = []
        self.symbol_table = SymbolTable()
        self.current_scope = self.symbol_table
        self.current_file = ""

        self._init_builtins()

    # Initialize built-in functions and types
    def _init_builtins(self):

        print_func = FunctionType( [ANY_TYPE], NULL_TYPE )
        self.symbol_table.define( Symbol( "print", print_func, SourceLocation( 0, 0 ) ) )

        for name, type_ in SQUIRREL_TYPES.items():
            self.symbol_table.define( Symbol( name, type_, SourceLocation(0, 0) ) )
        # self.symbol_table.define(Symbol("int", INT_TYPE, SourceLocation(0, 0)))
        # self.symbol_table.define(Symbol("char", CHAR_TYPE, SourceLocation(0, 0)))
        # self.symbol_table.define(Symbol("float", FLOAT_TYPE, SourceLocation(0, 0)))
        # self.symbol_table.define(Symbol("string", STRING_TYPE, SourceLocation(0, 0)))
        # self.symbol_table.define(Symbol("bool", BOOL_TYPE, SourceLocation(0, 0)))

    def error(self, message: str, location: SourceLocation, code: str | None = None):
        """ Add an error message """
        self.messages.append(AnalyzerMessage(ErrorSeverity.ERROR, message, location, code))

    def warning(self, message: str, location: SourceLocation, code: str | None = None):
        """ Add a warning message """
        self.messages.append(AnalyzerMessage(ErrorSeverity.WARNING, message, location, code))

    def info(self, message: str, location: SourceLocation, code: str | None = None):
        """ Add an info message """
        self.messages.append(AnalyzerMessage(ErrorSeverity.INFO, message, location, code))

    def enter_scope(self) -> SymbolTable:

        """ Enter a new scope """
        self.current_scope = self.current_scope.create_child_scope()
        return self.current_scope

    def exit_scope(self):

        """ Exit the current scope """
        if self.current_scope.parent:
            self.current_scope = self.current_scope.parent

    def check_file(self, filename: str, source_code: str) -> list[AnalyzerMessage]:

        """ Check a file """
        self.current_file = filename
        self.messages.clear()

        if not ANTLR_AVAILABLE:
            self.error("ANTLR4 not available for parsing", SourceLocation(1, 1))
            return self.messages

        # try:
            # This would parse using ANTLR and walk the parse tree
            # For now, we'll do basic validation
        self.find_type_annotations(source_code)

        # except Exception as e:
            # self.error(f"{str(e.__class__.__name__)}: {str(e)}", SourceLocation(1, 1))

        return self.messages

    def find_type_annotations(self, source_code: str):
        """Extract type annotations using ANTLR parser"""
        try:
            from type_extractor import SquirrelTypeExtractor
            
            extractor = SquirrelTypeExtractor()
            result = extractor.extract_from_string(source_code)
            
            if not result["success"]:
                self.error(f"Parse error: {result['error']}", SourceLocation(1, 1))
                return
            
            # Process extracted variables
            for var in result["variables"]:
                location = SourceLocation(var.location[0], var.location[1], self.current_file)
                
                if var.type_annotation:
                    # Report type annotation found
                    var_type = var.type_annotation
                    scope_info = f" in {var.scope}" if var.scope != "global" else ""
                    
                    if var.is_local:
                        self.info(f"Local variable '{var.name}': {var_type}{scope_info}", location)
                    elif var.is_parameter:
                        self.info(f"Parameter '{var.name}': {var_type}{scope_info}", location)
                    elif var.is_field:
                        self.info(f"Field '{var.name}': {var_type}{scope_info}", location)
                    else:
                        self.info(f"Variable '{var.name}': {var_type}{scope_info}", location)
                    
                    # Store type information for later use
                    print(f"--- {var.name} ==> {var_type} ({var.scope})")
            
            # Process extracted functions
            for func in result["functions"]:
                location = SourceLocation(func.location[0], func.location[1], self.current_file)
                
                # Report function with return type
                if func.return_type:
                    self.info(f"Function '{func.name}' returns: {func.return_type}", location)
                    print(f"--- function {func.name} ==> {func.return_type}")
                
                # Report parameters with types
                for param in func.parameters:
                    if param.type_annotation:
                        param_location = SourceLocation(param.location[0], param.location[1], self.current_file)
                        self.info(f"Parameter '{param.name}': {param.type_annotation}", param_location)
            
            # Process extracted classes
            for cls in result["classes"]:
                location = SourceLocation(cls.location[0], cls.location[1], self.current_file)
                self.info(f"Class '{cls.name}' defined", location)
                
                if cls.base_class:
                    self.info(f"Class '{cls.name}' extends '{cls.base_class}'", location)
                
                # Report constructor and method types
                if cls.constructor:
                    for param in cls.constructor.parameters:
                        if param.type_annotation:
                            param_location = SourceLocation(param.location[0], param.location[1], self.current_file)
                            self.info(f"Constructor parameter '{param.name}': {param.type_annotation}", param_location)
                
                for method in cls.methods:
                    if method.return_type:
                        method_location = SourceLocation(method.location[0], method.location[1], self.current_file)
                        self.info(f"Method '{method.name}' returns: {method.return_type}", method_location)
            
        except ImportError:
            self.error("Type extractor not available", SourceLocation(1, 1))
        except Exception as e:
            self.error(f"Type extraction failed: {str(e)}", SourceLocation(1, 1))

    # Strip type annotations from source code
    def strip_type_annotations(self, source_code: str) -> str:

        """ Strip type annotations from source code """
        stripper = TypeAnnotationStripper(source_code)
        return stripper.strip_annotations()


# Main analyzer class that coordinates type checking and annotation stripping
class SquirrelAnalyzer:

    """ Main analyzer class that coordinates type checking and annotation stripping """

    def __init__(self):
        self.type_checker = SquirrelTypeChecker()

    # Analyze a Squirrel file
    def analyze_file(self, filename: str, check_types: bool = True, strip_annotations: bool = False) -> dict[str, Any]:

        """ Analyze a Squirrel file """
        if not os.path.exists(filename):
            return {
                "success": False,
                "error": f"File not found: {filename}",
                "messages": [],
                "stripped_code": None
            }

        try:
            with open(filename, 'r', encoding='utf-8') as f:
                source_code = f.read()

        except Exception as e:

            return {
                "success": False,
                "error": f"Error reading file: {str(e)}",
                "messages": [],
                "stripped_code": None
            }

        messages = []
        stripped_code = None

        # Type checking
        if check_types:
            messages = self.type_checker.check_file(filename, source_code)

        # Strip type annotations
        if strip_annotations:
            stripped_code = self.type_checker.strip_type_annotations(source_code)

        return {
            "success": True,
            "error": None,
            "messages": messages,
            "stripped_code": stripped_code,
            "original_code": source_code
        }

    def analyze_string(self, source_code: str, filename: str = "<string>", check_types: bool = True, strip_annotations: bool = False) -> dict[str, Any]:

        """ Analyze Squirrel source code from a string """
        messages: list[AnalyzerMessage] = []
        stripped_code = None

        # Type checking
        if check_types:
            messages = self.type_checker.check_file(filename, source_code)

        # Strip type annotations
        if strip_annotations:
            stripped_code = self.type_checker.strip_type_annotations(source_code)

        return {
            "success": True,
            "error": None,
            "messages": messages,
            "stripped_code": stripped_code,
            "original_code": source_code
        }


def main():

    """ Main entry point """

    parser = argparse.ArgumentParser(
        description="Squirrel Static Type Analyzer",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=HELP_TEXT
    )

    parser.add_argument( "file", help="Squirrel source file to analyze" )
    parser.add_argument( "--check", "-c", action="store_true", default=True, help="Perform type checking (default: True)" )
    parser.add_argument( "--no-check", "-nc", action="store_false", dest="check", help="Skip type checking" )
    parser.add_argument( "--strip", "-s", action="store_true", help="Strip type annotations" )
    parser.add_argument( "--output", "-o", help="Output file for stripped code" )
    parser.add_argument( "--format", "-fmt", choices=["text", "json"], default="text", help="Output format for messages" )
    parser.add_argument( "--verbose", "-v", action="store_true", default=False, help="Verbose output" )

    args = parser.parse_args()

    analyzer = SquirrelAnalyzer()
    result = analyzer.analyze_file( args.file, check_types=args.check, strip_annotations=args.strip )

    if not result["success"]:
        print( f"Error: {result['error']}", file=sys.stderr )
        sys.exit(1)

    # Output messages
    if result["messages"]:
        if args.format == "json":
            message_dicts = []
            for msg in result["messages"]:
                message_dicts.append({
                    "severity": msg.severity.value,
                    "message": msg.message,
                    "location": {
                        "file": msg.location.file,
                        "line": msg.location.line,
                        "column": msg.location.column
                    },
                    "code": msg.code
                })
            print(json.dumps({"messages": message_dicts}, indent=2))
        else:
            for msg in result["messages"]:
                print(str(msg))

    # Output stripped code
    if args.strip and result["stripped_code"] is not None:
        if args.output:
            try:
                with open(args.output, 'w', encoding='utf-8') as f:
                    f.write(result["stripped_code"])
                print(f"Stripped code written to: {args.output}")
            except Exception as e:
                print(f"Error writing output file: {str(e)}", file=sys.stderr)
                sys.exit(1)
        elif args.verbose or not result["messages"]:
            print("=== Stripped Code ===")
            print(result["stripped_code"])

    # Exit with appropriate code
    has_errors = any(msg.severity == ErrorSeverity.ERROR for msg in result["messages"])
    sys.exit(1 if has_errors else 0)


if __name__ == "__main__":
    main()
